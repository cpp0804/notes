## 参考博文
[聊聊Linux 五种IO模型](https://www.jianshu.com/p/486b0965c296)



[TOC]



# 1. 用户空间与内核空间
Linux分为内核态(Kernel model)和用户态(User model)，CPU会在两个model之间切换：
1. 内核态：内核态代码拥有完全的底层资源控制权限，可以执行任何CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的。内核态的指令包括：启动I/O，内存清零，修改程序状态字，设置时钟，允许/终止中断和停机。内核态的程序崩溃会导致PC停机
2. 用户态：是用户程序能够使用的指令，不能直接访问底层硬件和内存地址。用户态运行的程序必须委托系统调用来访问硬件和内存。用户态的指令包括：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）

操作系统的核心是内核，他独立于应用程序可以访问受保护的内存空间和访问底层硬件。

为了保证用户进程不能操作内核，操作系统将虚拟存储空间分为两部分：
1. 内核空间：供内核态使用，最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）
2. 用户空间：共用户态使用，较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）


用户态切换到内核态：
1）系统调用
2）异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。
3）外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。


# 2. 进程切换
任何进程都是在内核的支持下进行的，内核会挂起正在CPU上运行的进程,然后恢复执行之前挂起的某个进程,这个过程称为进程切换

进程切换过程:
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。


# 3. 进程的阻塞
正在执行的进程,如果请求系统资源失败、等待某个操作的完成，就会执行阻塞原语将自己由运行状态变成阻塞状态。

进程的阻塞是一种主动行为，只有获得CPU的进程才有可能阻塞

# 4. 文件描述符fd
是一个非负整数的索引，代表指向文件的引用

当程序打开或创建文件时，内核会向进程返回fd


# 5. 缓存IO
在Linux的缓存IO机制中，OS会将IO的数据缓存在文件系统的页缓存中。也就是说IO数据会有两个阶段：
1. 先被拷贝到OS内核的缓冲区
2. 再从缓冲区拷贝到应用程序的地址空间

