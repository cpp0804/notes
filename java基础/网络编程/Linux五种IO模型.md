## 参考博文
[聊聊Linux 五种IO模型](https://www.jianshu.com/p/486b0965c296)
[linux五种IO模型](https://juejin.im/post/5c725dbe51882575e37ef9ed)
[IO 模型 - Unix IO 模型](https://www.pdai.tech/md/java/io/java-io-model.html)
[聊聊IO多路复用之select、poll、epoll详解](https://www.jianshu.com/p/dfd940e7fca2) ⚠️


[TOC]



# 1. 几个概念
[几个概念](./几个概念.md)



# 2. Linux IO模型
网络IO的本质是socket的读取，socket在Linux中被抽象成流。

具体对于socket流来说，会经历两个阶段：
```
第一步：等待网络上的数据分组到达，然后复制到内核的某个缓冲区
第二步：把数据从内核缓冲区复制到应用进程缓冲区
```

客户端发起一个http请求，服务器端处理响应http请求，这一过程在服务器端以网络IO的角度，经历了以下阶段
```
1.用户空间进程通过系统调用函数reveform接收等待接收数据包，并将接收到的数据包在内核通过四表五链检查网络状态，若通过网络检查，则提交给用户空间http进程；

2.http进程解析请求，并发起系统调用read函数，到达内核空间；

3.内核空间执行read函数读取磁盘内容，并将此内容加载至内存；

4.内核空间提交给用户空间http进程，告知数据已经read完毕；

5.用户空间http进程根据请求报文进行构建响应报文；

6.构建完http响应报文后，通知内核空间构建网络封装；

7.内核空间再次通过四表五链网络状态，通过网卡发送构建好的http的响应报文。
```


## 同步阻塞IO（bloking IO/BIO）
用户空间的应用程序主动等待数据的返回，并且用户进程在两个阶段都处于阻塞状态

![同步阻塞IO](../pic/Linux五种IO模型_同步阻塞IO.png)

```
我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。
女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了
```

## 同步非阻塞IO（non-blocking IO/NIO）
在第一阶段用户进程每隔一会就来问数据是否准备好了，用的是轮询的方式。
在第二阶段数据复制时阻塞

![同步非阻塞IO](../pic/Linux五种IO模型_同步非阻塞IO.png)

缺点是轮询会消耗CPU时间

```
我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦
```


## 多路复用IO（multiplexing IO）
[Reactor和Proactor](./Reactor和Proactor.md)
轮询的工作不由用户进程来做，而是统一的交给内核，内核负责同时对多个socket进行监听。

select、poll、epoll 就是实现的多路复用IO。他们可以同时处理多个网络连接的IO，会不断轮询负责的所有socket。当其中一个数据准备好了就通知用户进程。然后用户进程再执行recvform系统调用拷贝数据

但是当用户进程调用了select后，还是会一直处于阻塞状态，对每个socket来说还是同步非阻塞IO。只不过可以通过把多个IO的阻塞复用到一个select阻塞上，实现在==单线程==的情况下可以同时处理多个客户端的socket请求

他也是同步阻塞的

多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好

![多路复用IO](../pic/Linux五种IO模型_多路复用IO.png)

```
餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。
```


## 异步非阻塞IO（asynchronous IO/AIO）
用户进行系统调用之后，就直接去做别的事情，两个阶段都不阻塞，等内核把数据复制好了之后给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程


![异步非阻塞IO](../pic/Linux五种IO模型_异步非阻塞IO.png)


```
女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了
```

## 信号驱动式IO（signal-driven IO）
应用程序建立一个信号处理程序，它可以继续运行不阻塞。当数据准备好后，进程会收到一个SIGIO信号，可以在信号处理程序中调用I/O操作函数处理数据


## IO模型比较

![IO模型比较](../pic/Linux五种IO模型_IO模型比较.png)


