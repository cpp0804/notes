## 参考博文
[堆和堆排序：为什么说堆排序没有快速排序快](https://blog.csdn.net/every__day/article/details/86580883)
[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)
[图解排序算法(三)之堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)


# 汇总
![排序_排序汇总](./pic/排序_排序汇总.png)


冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成； 

时间复杂度：O（n2）

选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

时间复杂度：O（n2）

快速排序：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有.

时间复杂度：O（nlogn）

归并排序（Merge）是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

时间复杂度：O（nlogn）

堆排序: 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

时间复杂度：O（nlogn）

桶排序: 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

时间复杂度：O（n+k）



# 堆和堆排序：为什么说堆排序没有快速排序快 
1. 堆排序访问数据的方式没有快速排序友好
对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶进行堆化，会依次访问数组下标是1，2，4，8的元素，而不像快速排序那样，局部顺序访问，所以，这样对CPU缓存是不友好的

2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序
我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程是由两个基本操作组成的，比较和交换。快速排序交换的次数不会比逆序度多。

但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对选择顺序，导致数据有序度降低。比如对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了



十分钟手撕代码：找出给定字符串中所有长度大于等于3的回文。